<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>1Table OCR → Google Sheets</title>
<!-- Tesseract.js (OCR) -->
<script src="https://unpkg.com/tesseract.js@v5.1.1/dist/tesseract.min.js"></script>
<!-- OpenCV.js (table/line detection) -->
<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady();" ></script>
<style>
  :root { --gap: 10px; }
  body { font-family: system-ui, Arial, sans-serif; margin: 0; padding: 16px; background: #f7f7fb; }
  h1 { margin: 0 0 12px; font-size: 20px; }
  .row { display: grid; grid-template-columns: 1fr 1fr; gap: var(--gap); }
  .card { background: #fff; border-radius: 12px; padding: 14px; box-shadow: 0 4px 18px rgba(0,0,0,.06); }
  .controls { display: grid; grid-template-columns: 1fr 1fr; gap: var(--gap); }
  label { font-size: 12px; color: #555; }
  input, button, select, textarea { width: 100%; padding: 10px; border-radius: 10px; border: 1px solid #ddd; background: #fff; }
  button { cursor: pointer; font-weight: 600; }
  button.primary { background: #3b82f6; color: #fff; border: none; }
  button.secondary { background: #10b981; color: #fff; border: none; }
  #preview { width: 100%; background: #eee; border-radius: 8px; }
  #overlay { position:absolute; top:0; left:0; pointer-events:none; }
  #progress { height: 10px; background: #e5e7eb; border-radius: 10px; overflow: hidden; }
  #bar { height: 10px; width: 0%; background: #3b82f6; }
  table { width:100%; border-collapse: collapse; }
  th, td { text-align:left; border-bottom:1px solid #eee; padding:8px; vertical-align: top; }
  .muted { color:#666; font-size:12px; }
  .small { font-size: 12px; }
  .canvas-container {
    position: relative;
    margin-top: 12px;
  }
  .line {
    position: absolute;
    pointer-events: all;
    cursor: move;
    z-index: 10;
  }
  .vertical-line {
    width: 2px;
    height: 100%;
    background: rgba(0, 0, 255, 0.7);
  }
  .horizontal-line {
    height: 2px;
    width: 100%;
    background: rgba(0, 150, 0, 0.7);
  }
</style>
</head>
<body>
  <h1>OCR table → Google Sheets</h1>

  <div class="row">
    <!-- LEFT: Image + controls -->
    <div class="card">
      <div class="controls">
        <div>
          <label>Upload table photo / scan</label>
          <input type="file" id="file" accept="image/*" />
        </div>
        <div>
          <label>Or paste image URL</label>
          <input type="url" id="imgUrl" placeholder="https://..." />
        </div>
      </div>

      <div class="canvas-container">
        <canvas id="preview"></canvas>
        <canvas id="overlay"></canvas>
        <div id="lines-container"></div>
      </div>

      <div style="display:grid;grid-template-columns:repeat(5,1fr);gap:var(--gap);margin-top:12px;">
        <div>
          <label>Binary block size</label>
          <input type="number" id="blk" value="25" />
          <div class="muted small">Adaptive threshold (odd, ~15–35)</div>
        </div>
        <div>
          <label>Binary C</label>
          <input type="number" id="Cval" value="10" />
          <div class="muted small">Higher → darker</div>
        </div>
        <div>
          <label>Horizontal kernel (px)</label>
          <input type="number" id="hks" value="50" />
          <div class="muted small">Line length sensitivity</div>
        </div>
        <div>
          <label>Vertical kernel (px)</label>
          <input type="number" id="vks" value="40" />
          <div class="muted small">Column detection</div>
        </div>
        <div>
          <label>Min cell height (px)</label>
          <input type="number" id="minh" value="40" />
          <div class="muted small">Row filtering</div>
        </div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:var(--gap);margin-top:12px;">
        <button id="scan" class="primary" disabled>Scan OCR</button>
        <button id="reset">Reset</button>
      </div>

      <div id="progress" style="margin-top:12px;"><div id="bar"></div></div>
      <div style="margin-top:8px;">
        <label>Logs</label>
        <textarea id="log" rows="8" readonly style="resize:vertical;"></textarea>
      </div>
    </div>

    <!-- RIGHT: Output + send -->
    <div class="card">
      <div class="controls">
        <div>
          <label>Apps Script Web App URL</label>
          <input type="url" id="scriptUrl" placeholder="Paste your deployed Web App URL here" />
        </div>
        <div>
          <label>Security token (must match Apps Script TOKEN)</label>
          <input type="text" id="token" placeholder="CHANGE_ME_TO_SOMETHING_RANDOM" />
        </div>
      </div>

      <div style="margin-top:12px;">
        <label>Parsed rows (review before sending)</label>
        <div class="muted small">Columns sent to Google Sheets: <b>Company name, Person In Charge, Tel/Fax, Company Address, Project</b></div>
        <div style="overflow:auto;max-height:360px;border:1px solid #eee;border-radius:8px;margin-top:6px;">
          <table id="outTable">
            <thead>
              <tr>
                <th>#</th>
                <th>Company name</th>
                <th>Person In Charge</th>
                <th>Tel/Fax</th>
                <th>Company Address</th>
                <th>Project</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div style="display:grid;grid-template-columns:1fr 1fr;gap:var(--gap);margin-top:12px;">
        <button id="send" class="secondary" disabled>Send to Google Sheet</button>
        <button id="download">Download CSV</button>
      </div>
    </div>
  </div>

<script>
/* ---------- Helpers ---------- */
const $ = (id) => document.getElementById(id);
const log = (msg) => { const t=$('log'); t.value += `[${new Date().toLocaleTimeString()}] ${msg}\n`; t.scrollTop = t.scrollHeight; };
const setProgress = (p) => { $('bar').style.width = `${Math.max(0, Math.min(100,p))}%`; };

let cvReady = false, srcImg=null, srcMat=null, scale=1;
let columnXs = [];   // x boundaries for columns
let rowYs = [];      // y boundaries for rows
let rowsOut = [];    // rows mapped to desired order
let isDragging = false;
let currentLine = null;
let initialX = 0;
let initialY = 0;

function onOpenCvReady(){ cvReady = true; log('OpenCV.js loaded'); maybeEnableScan(); }
function maybeEnableScan(){ if (cvReady && srcImg) $('scan').disabled = false; }

function fitCanvasToImage(img){
  const maxW = 1000;
  const ratio = img.width > maxW ? maxW / img.width : 1;
  const w = Math.round(img.width * ratio), h = Math.round(img.height * ratio);
  scale = ratio;

  const c = $('preview'), o = $('overlay');
  [c.width, c.height, o.width, o.height] = [w, h, w, h];

  const ctx = c.getContext('2d');
  ctx.clearRect(0,0,w,h);
  ctx.drawImage(img, 0, 0, w, h);
}

function loadImageFromFile(file){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.onload = ()=>resolve(img);
    img.onerror = reject;
    const r = new FileReader();
    r.onload = e => img.src = e.target.result;
    r.readAsDataURL(file);
  });
}

function loadImageFromUrl(url){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = ()=>resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}

$('file').addEventListener('change', async (e)=>{
  if (!e.target.files.length) return;
  srcImg = await loadImageFromFile(e.target.files[0]);
  fitCanvasToImage(srcImg);
  log(`Loaded image ${srcImg.width}×${srcImg.height}`);
  maybeEnableScan();
});
$('imgUrl').addEventListener('change', async (e)=>{
  if (!e.target.value) return;
  try{
    srcImg = await loadImageFromUrl(e.target.value);
    fitCanvasToImage(srcImg);
    log(`Loaded image ${srcImg.width}×${srcImg.height} (from URL)`);
    maybeEnableScan();
  }catch(err){ log('Failed to load URL image'); }
});

$('reset').addEventListener('click', ()=>{
  columnXs = []; rowYs = []; rowsOut = [];
  $('overlay').getContext('2d').clearRect(0,0,$('overlay').width,$('overlay').height);
  $('outTable').querySelector('tbody').innerHTML='';
  $('scan').disabled = !srcImg || !cvReady;
  $('send').disabled = true;
  setProgress(0);
  clearLines();
  log('Reset.');
});

function clearLines() {
  $('lines-container').innerHTML = '';
}

function createDraggableLines() {
  clearLines();
  const container = $('lines-container');
  const preview = $('preview');

  // Vertical lines (columns)
  for (let i = 0; i < columnXs.length; i++) {
    const line = document.createElement('div');
    line.className = 'line vertical-line';
    line.dataset.type = 'vertical';
    line.dataset.index = i;
    line.style.left = `${columnXs[i] * scale}px`;
    container.appendChild(line);

    line.addEventListener('mousedown', startLineDrag);
  }

  // Horizontal lines (rows)
  for (let i = 0; i < rowYs.length; i++) {
    const line = document.createElement('div');
    line.className = 'line horizontal-line';
    line.dataset.type = 'horizontal';
    line.dataset.index = i;
    line.style.top = `${rowYs[i] * scale}px`;
    container.appendChild(line);

    line.addEventListener('mousedown', startLineDrag);
  }

  document.addEventListener('mousemove', dragLine);
  document.addEventListener('mouseup', stopLineDrag);
}

function startLineDrag(e) {
  e.preventDefault();
  isDragging = true;
  currentLine = e.target;
  initialX = e.clientX;
  initialY = e.clientY;
  
  // Bring the line to front while dragging
  currentLine.style.zIndex = '20';
}

function dragLine(e) {
  if (!isDragging || !currentLine) return;
  
  const type = currentLine.dataset.type;
  const index = parseInt(currentLine.dataset.index);
  const preview = $('preview');
  const rect = preview.getBoundingClientRect();
  
  if (type === 'vertical') {
    const newX = Math.max(0, Math.min(preview.width, currentLine.offsetLeft + (e.clientX - initialX)));
    currentLine.style.left = `${newX}px`;
    columnXs[index] = Math.round(newX / scale);
    initialX = e.clientX;
  } else {
    const newY = Math.max(0, Math.min(preview.height, currentLine.offsetTop + (e.clientY - initialY)));
    currentLine.style.top = `${newY}px`;
    rowYs[index] = Math.round(newY / scale);
    initialY = e.clientY;
  }
  
  drawOverlayRects();
}

function stopLineDrag() {
  if (currentLine) {
    currentLine.style.zIndex = '10';
  }
  isDragging = false;
  currentLine = null;
  log('Grid lines adjusted manually');
}

function drawOverlayRects(){
  const o = $('overlay'), ctx = o.getContext('2d');
  ctx.clearRect(0,0,o.width,o.height);

  // Draw columns
  ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,255,.7)';
  for (const x of columnXs) { ctx.beginPath(); ctx.moveTo(x*scale,0); ctx.lineTo(x*scale,o.height); ctx.stroke(); }

  // Draw rows
  ctx.strokeStyle = 'rgba(0,150,0,.7)';
  for (const y of rowYs) { ctx.beginPath(); ctx.moveTo(0,y*scale); ctx.lineTo(o.width,y*scale); ctx.stroke(); }
}

/* ---------- Table detection with OpenCV ---------- */
function detectGridAndCells() {
  // Only run detection if we haven't manually adjusted lines yet
  if (columnXs.length === 0 || rowYs.length === 0) {
    const blk = Math.max(3, parseInt($('blk').value)|0) | 1; // odd
    const Cval = parseInt($('Cval').value)|0;
    const hks = Math.max(5, parseInt($('hks').value)|0);
    const vks = Math.max(5, parseInt($('vks').value)|0);
    const minh = Math.max(10, parseInt($('minh').value)|0);

    // Build cv.Mat from canvas
    const c = $('preview');
    const matRGBA = cv.imread(c);
    const mat = new cv.Mat();
    cv.cvtColor(matRGBA, mat, cv.COLOR_RGBA2GRAY);

    // Adaptive threshold to get binary
    const bin = new cv.Mat();
    cv.adaptiveThreshold(mat, bin, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY_INV, blk, Cval);

    // Horizontal lines
    const horizontalsize = hks;
    const horizontalStructure = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(horizontalsize, 1));
    const horizontal = new cv.Mat();
    cv.erode(bin, horizontal, horizontalStructure);
    cv.dilate(horizontal, horizontal, horizontalStructure);

    // Vertical lines
    const verticalsize = vks;
    const verticalStructure = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(1, verticalsize));
    const vertical = new cv.Mat();
    cv.erode(bin, vertical, verticalStructure);
    cv.dilate(vertical, vertical, verticalStructure);

    // Get contours of horizontal lines -> y positions
    let contours = new cv.MatVector(), hierarchy = new cv.Mat();
    cv.findContours(horizontal, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    const yCandidates = [];
    for (let i=0;i<contours.size();i++){
      const r = cv.boundingRect(contours.get(i));
      if (r.width > c.width*0.4) yCandidates.push(r.y);
    }
    yCandidates.sort((a,b)=>a-b);

    // dedupe y's (merge near)
    rowYs = [];
    for (const y of yCandidates) {
      if (!rowYs.length || Math.abs(y - rowYs[rowYs.length-1]) > minh) rowYs.push(y);
    }
    // add bottom edge
    rowYs.push(c.height);

    // Vertical lines -> x positions
    contours.delete(); hierarchy.delete();
    contours = new cv.MatVector(); hierarchy = new cv.Mat();
    cv.findContours(vertical, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    const xCandidates = [];
    for (let i=0;i<contours.size();i++){
      const r = cv.boundingRect(contours.get(i));
      if (r.height > c.height*0.4) xCandidates.push(r.x);
    }
    xCandidates.sort((a,b)=>a-b);
    columnXs = [0];
    for (const x of xCandidates) {
      if (Math.abs(x - columnXs[columnXs.length-1]) > 15) columnXs.push(x);
    }
    columnXs.push(c.width);

    bin.delete(); mat.delete(); matRGBA.delete();
    horizontalStructure.delete(); verticalStructure.delete();
    horizontal.delete(); vertical.delete();
    contours.delete(); hierarchy.delete();

    log(`Detected ~${rowYs.length-1} row bands and ${columnXs.length-1} columns.`);
  }

  drawOverlayRects();
  createDraggableLines();
}

/* ---------- OCR with Tesseract ---------- */
async function runOCRAndAssemble() {
  setProgress(2);
  
  // Only detect grid if we haven't manually adjusted lines yet
  if (columnXs.length === 0 || rowYs.length === 0) {
    detectGridAndCells();
  }

  const worker = await Tesseract.createWorker('eng', 1, {
    logger: m => {
      if (m.status === 'recognizing text') setProgress(5 + Math.round(m.progress*85));
    }
  });

  const data = await worker.recognize($('preview'));
  await worker.terminate();
  setProgress(92);

  // Index all words with their centers
  const words = (data && data.data && data.data.words) ? data.data.words : [];
  const toks = words
    .filter(w => (w.text||'').trim().length)
    .map(w => ({
      text: w.text.trim(),
      x: (w.bbox.x0 + w.bbox.x1) / 2,
      y: (w.bbox.y0 + w.bbox.y1) / 2
    }));

  // Build empty grid cells
  const grid = []; // grid[row][col] = text
  for (let r=0; r<rowYs.length-1; r++) {
    const row = new Array(Math.max(7, columnXs.length-1)).fill('');
    grid.push(row);
  }

  // Map each token to a cell by [row band, column band]
  function findBand(val, bounds){
    for (let i=0;i<bounds.length-1;i++){
      if (val >= bounds[i] && val < bounds[i+1]) return i;
    }
    return bounds.length-2;
  }

  for (const t of toks) {
    const r = findBand(t.y, rowYs);
    const c = findBand(t.x, columnXs);
    if (r >= 0 && c >= 0 && r < grid.length && c < grid[r].length) {
      grid[r][c] = (grid[r][c] ? grid[r][c]+' ' : '') + t.text;
    }
  }

  // Your original table columns:
  // [0] Proposal No | [1] Company Name | [2] Project | [3] Company Address
  // [4] Tel/Fax     | [5] Person In Charge | [6] Fees
  // Some scans might detect more/fewer columns; we guard against that.
  const rows = [];
  for (let r=0; r<grid.length; r++){
    const cells = grid[r].map(s => (s||'').replace(/\s{2,}/g,' ').trim());
    if (cells.join('').length < 4) continue; // skip blank rows

    // Try to coalesce if detection found >7 cols
    const col = (arr, idx) => (idx < arr.length ? arr[idx] : '');

    const proposal = col(cells,0);
    const company  = col(cells,1);
    const project  = col(cells,2);
    const address  = col(cells,3);
    const telFax   = col(cells,4);
    const pic      = col(cells,5);
    const fees     = col(cells,6);

    // Reorder to your Google Sheet order:
    rows.push([company, pic, telFax, address, project]);
  }

  rowsOut = rows;
  setProgress(98);
  renderTable(rowsOut);
  $('send').disabled = rowsOut.length === 0;
  log(`OCR done. Parsed ${rowsOut.length} rows.`);
  setProgress(100);
}

function renderTable(rows){
  const tbody = $('outTable').querySelector('tbody');
  tbody.innerHTML = '';
  let i=1;
  for (const r of rows){
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${i++}</td>
      <td>${escapeHtml(r[0])}</td>
      <td>${escapeHtml(r[1])}</td>
      <td>${escapeHtml(r[2])}</td>
      <td>${escapeHtml(r[3])}</td>
      <td>${escapeHtml(r[4])}</td>`;
    tbody.appendChild(tr);
  }
}
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g,m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

$('scan').addEventListener('click', async ()=>{
  if (!srcImg || !cvReady) return;
  log('Starting OCR…');
  setProgress(0);
  await runOCRAndAssemble();
});

/* ---------- Send to Google Sheets ---------- */
$('send').addEventListener('click', async ()=>{
  const url = $('scriptUrl').value.trim();
  const token = $('token').value.trim();
  if (!url) { alert('Paste your Apps Script Web App URL'); return; }
  if (!rowsOut.length) { alert('No rows to send'); return; }

  // Use form-data to avoid CORS preflight
  const payload = {
    token,
    rows: rowsOut,
    meta: {
      source: 'github-pages-ocr',
      imageName: ($('file').files[0] && $('file').files[0].name) || $('imgUrl').value || 'unknown'
    }
  };
  const form = new FormData();
  form.append('payload', JSON.stringify(payload));

  log('Sending to Google Sheets…');
  try{
    const res = await fetch(url, { method: 'POST', body: form });
    // Apps Script returns 200; try to parse JSON if possible
    let json = {};
    try { json = await res.json(); } catch(e){}
    if (res.ok && (json.ok === undefined || json.ok === true)) {
      log(`✅ Sent successfully. Inserted ${(json.inserted||rowsOut.length)} rows.`);
      alert('Sent to Google Sheets!');
    } else {
      log(`❌ Failed: ${JSON.stringify(json)}`);
      alert('Failed (see logs).');
    }
  }catch(err){
    log('❌ Network error: '+err.message);
    alert('Network error (see logs).');
  }
});

/* ---------- CSV Download (optional) ---------- */
$('download').addEventListener('click', ()=>{
  const header = ['Company name','Person In Charge','Tel/Fax','Company Address','Project'];
  const lines = [header, ...rowsOut].map(r =>
    r.map(x => `"${String(x||'').replace(/"/g,'""')}"`).join(',')
  );
  const blob = new Blob([lines.join('\n')], {type:'text/csv;charset=utf-8;'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'ocr_rows.csv';
  a.click();
});

/* ---------- Start when image present ---------- */
function maybeBootWithSample(){
  // No default sample to keep it lightweight.
}
maybeBootWithSample();

</script>
</body>
</html>
