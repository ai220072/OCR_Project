<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>OCR → Google Sheet</title>
  <script src="https://unpkg.com/tesseract.js@v4.0.2/dist/tesseract.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 16px; max-width:900px; margin:auto; }
    input, button { margin:8px 0; }
    img { max-width: 100%; height: auto; border: 1px solid #ddd; margin-top:8px; }
    table { width:100%; border-collapse:collapse; margin-top:12px; }
    th, td { border:1px solid #ccc; padding:6px; text-align:left; }
    #progress { margin-top:8px; }
  </style>
</head>
<body>
  <h1>OCR → Google Sheet</h1>

  <p>Select or take a photo (mobile camera) of the table row(s):</p>
  <input id="file" type="file" accept="image/*" capture="environment" />
  <button id="processBtn">Run OCR & Parse</button>
  <div id="progress"></div>
  <img id="preview" alt="preview" />

  <h3>Detected rows</h3>
  <div id="results"></div>

  <p><button id="sendAllBtn">Send all detected rows to Google Sheet</button></p>

<script>
const APP_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxdqykMc6lSTqHRK_GAcWJ9T3Qe3nl6WWCAauU0agijwG7LAty9JPqbIJf3x2wP9cjRHg/exec'; 

const fileInput = document.getElementById('file');
const preview = document.getElementById('preview');
const progress = document.getElementById('progress');
const resultsDiv = document.getElementById('results');
const processBtn = document.getElementById('processBtn');
const sendAllBtn = document.getElementById('sendAllBtn');

let lastParsedRows = [];

fileInput.addEventListener('change', () => {
  const f = fileInput.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  preview.src = url;
});

processBtn.addEventListener('click', async () => {
  const f = fileInput.files[0];
  if (!f) { alert('Choose an image first'); return; }
  progress.innerText = 'Starting OCR...';
  const { data } = await Tesseract.recognize(f, 'eng', {
    logger: m => {
      if (m.status === 'recognizing text') {
        progress.innerText = `OCR: ${(m.progress*100).toFixed(1)}%`;
      } else {
        progress.innerText = m.status;
      }
    }
  });

  progress.innerText = 'Parsing text...';
  const lines = (data.lines || []).map(l => (l.text || '').trim()).filter(Boolean);

  // fallback if lines not present
  if (lines.length === 0 && data.text) {
    data.text.split(/\r?\n/).forEach(l => {
      if (l.trim()) lines.push(l.trim());
    });
  }

  const groups = groupRowsByProposal(lines);
  const parsedRows = groups.map(parseGroupToRow);
  lastParsedRows = parsedRows;
  showResults(parsedRows);
  progress.innerText = 'Done';
});

sendAllBtn.addEventListener('click', async () => {
  if (!lastParsedRows.length) { alert('No parsed rows to send. Run OCR first.'); return; }
  sendAllBtn.disabled = true;
  try {
    for (let i=0;i<lastParsedRows.length;i++){
      await sendToAppsScript(lastParsedRows[i]);
    }
    alert('All rows sent!');
  } catch (err) {
    alert('Error sending: ' + err);
  }
  sendAllBtn.disabled = false;
});

function groupRowsByProposal(lines) {
  // A row starts where we see a proposal code like "PZ4 0813" or "PZ0813"
  const groups = [];
  let current = [];
  const proposalRegex = /\bPZ\s*\d{3,}\b/i;
  for (const line of lines) {
    if (proposalRegex.test(line)) {
      if (current.length) groups.push(current);
      current = [line];
    } else {
      if (current.length) current.push(line);
      else {
        // garbage before first proposal — ignore or collect
      }
    }
  }
  if (current.length) groups.push(current);
  return groups;
}

function parseGroupToRow(lines) {
  // lines: array of strings for a single table row (top->bottom)
  // Heuristics to extract fields.

  const entire = lines.join(' | ');

  // 1) proposalNo
  const proposalMatch = entire.match(/\bPZ\s*\d{3,}\b/i);
  const proposalNo = proposalMatch ? proposalMatch[0].replace(/\s+/g,' ') : '';

  // 2) type (ISO, Haccp, TS, etc.)
  let typeMatch = entire.match(/\b(ISO\s*\d*|HACCP|Haccp|TS|TS\b)\b/i);
  const typeOfProject = typeMatch ? typeMatch[0].trim() : '';

  // 3) tel / fax lines
  const telFaxLines = lines.filter(l => /tel[:\s]|\bfax[:\s]|\d{2,}-\d{5,}|\+\d{2,}/i.test(l));
  const telFax = telFaxLines.join(' ; ');

  // 4) person in charge - look for honorifics and capitalized name segments
  let person = '';
  for (const l of lines.slice().reverse()) { // often on right / lower area
    if (/\b(Mr|Ms|Mrs|En|Pn|Dr|Dato|Dato')\.?\s+[A-Z]/i.test(l) || /^[A-Z][a-z]+ [A-Z][a-z]+/.test(l)) {
      person = l;
      break;
    }
  }

  // 5) company name — typically after proposal line
  let companyName = '';
  if (lines.length > 1) {
    // first candidate after proposal that is not type/tel/person
    for (let i=1;i<lines.length;i++){
      const l = lines[i];
      if (!l) continue;
      if (l === typeOfProject) continue;
      if (/tel[:\s]|\bfax[:\s]/i.test(l)) continue;
      if (/\b(Mr|Ms|Mrs|En|Pn|Dr|Dato)\b/i.test(l)) continue;
      companyName = l;
      break;
    }
  }

  // 6) company address — lines between companyName and the Tel or person line
  let addr = [];
  if (companyName) {
    let start = lines.indexOf(companyName);
    if (start >= 0) {
      for (let k=start+1; k<lines.length; k++) {
        const l = lines[k];
        if (/tel[:\s]|\bfax[:\s]/i.test(l)) break;
        if (/\b(Mr|Ms|Mrs|En|Pn|Dr|Dato)\b/i.test(l)) break;
        if (l === typeOfProject) break;
        addr.push(l);
      }
    }
  }
  if (addr.length === 0) {
    // fallback: take any long lines that look like address
    addr = lines.filter(l => /Jalan|Kawasan|Komplex|Lot|Block|Penang|Kelantan|Kuantan|Perusahaan|Kota|Alamat/i.test(l));
  }
  const companyAddress = addr.join(', ');

  // 7) state: simple search by state names (Malaysia)
  const STATES = ['KELANTAN','PENANG','PULAU PINANG','JOHOR','KEDAH','PERAK','SELANGOR','KUALA LUMPUR','NEGERI SEMBILAN','PAHANG','TERENGGANU','MELAKA','SABAH','SARAWAK','PUTRAJAYA','LABUAN'];
  let stateFound = '';
  for (const s of STATES) {
    if (companyAddress.toUpperCase().includes(s) || entire.toUpperCase().includes(s)) {
      stateFound = s;
      break;
    }
  }

  return {
    proposalNo: proposalNo.trim(),
    companyName: companyName.trim(),
    personInCharge: person.trim(),
    telFax: telFax.trim(),
    state: stateFound,
    companyAddress: companyAddress.trim(),
    typeOfProject: typeOfProject.trim()
  };
}

function showResults(rows) {
  if (!rows.length) {
    resultsDiv.innerHTML = '<p>No rows detected. Try improving photo (straight overhead, crop close to table, good lighting).</p>';
    return;
  }
  let html = '<table><thead><tr><th>Proposal No</th><th>Company Name</th><th>Person In Charge</th><th>Tel/Fax</th><th>State</th><th>Address</th><th>Type</th></tr></thead><tbody>';
  rows.forEach((r, idx) => {
    html += `<tr>
      <td>${escapeHtml(r.proposalNo)}</td>
      <td>${escapeHtml(r.companyName)}</td>
      <td>${escapeHtml(r.personInCharge)}</td>
      <td>${escapeHtml(r.telFax)}</td>
      <td>${escapeHtml(r.state)}</td>
      <td>${escapeHtml(r.companyAddress)}</td>
      <td>${escapeHtml(r.typeOfProject)}</td>
    </tr>`;
  });
  html += '</tbody></table>';
  resultsDiv.innerHTML = html;
}

function escapeHtml(s){ return (s||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

async function sendToAppsScript(payload) {
  // Use URLSearchParams to avoid CORS preflight (sends as form-encoded)
  const form = new URLSearchParams();
  form.append('data', JSON.stringify(payload));
  const resp = await fetch(APP_SCRIPT_URL, { method:'POST', body: form });
  if (!resp.ok) throw new Error('Network response not ok: ' + resp.statusText);
  const j = await resp.json();
  if (j.status !== 'ok') throw new Error('Apps Script error: ' + JSON.stringify(j));
  return j;
}
</script>
</body>
</html>
